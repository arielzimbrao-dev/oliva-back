import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Resend } from 'resend';
import { UserRepository } from '../../entities/repository/user.repository';
import { ChurchRepository } from '../../entities/repository/church.repository';
import { getResetPasswordEmail, getWelcomeEmail, getPaymentFailedEmail } from './templates/template.loader';
import { getTranslation } from './i18n/translations';

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  private readonly resend: Resend | null = null;
  private readonly isDevelopment: boolean;
  private readonly fromEmail: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly userRepository: UserRepository,
    private readonly churchRepository: ChurchRepository,
  ) {
    this.isDevelopment = this.configService.get<string>('ENV') === 'development';
    
    const apiKey = this.configService.get<string>('RESEND_API_KEY');
    this.fromEmail = this.configService.get<string>('RESEND_FROM_EMAIL') || 
                     this.configService.get<string>('EMAIL_USER') || 
                     'noreply@oliva.church';
    
    if (!apiKey) {
      this.logger.warn('RESEND_API_KEY not configured. Email service will be disabled.');
      return;
    }
    
    try {
      this.resend = new Resend(apiKey);
      this.logger.log('✓ Resend email service initialized');
    } catch (error) {
      this.logger.error('Failed to initialize Resend:', error.message);
    }
  }



  /**
   * Send password reset email to user
   * @param email User email address
   * @param resetToken Secure reset token generated by AuthService
   * @param resetUrl Full reset URL with token
   * @returns Promise<boolean> Success status
   */
  async sendPasswordReset(
    email: string,
    resetToken: string,
    resetUrl: string,
  ): Promise<boolean> {
    try {
      if (!this.resend) {
        this.logger.error('Resend not initialized. Cannot send password reset email.');
        return false;
      }

      // Find user by email (without leaking user existence info)
      const user = await this.userRepository.findOne({ 
        where: { email },
        relations: ['church'],
      });
      
      if (!user) {
        // Don't reveal if user exists - log internally but return success to client
        this.logger.warn(`Password reset requested for non-existent email (not logged): ${this.maskEmail(email)}`);
        return true; // Security: Don't leak user existence
      }

      // Get church preferred language
      const language = user.church?.preferredLanguage || 'pt';
      const t = getTranslation(language).resetPassword;
      
      const userName = 'Usuário'; // User entity doesn't have name field
      const htmlContent = getResetPasswordEmail(userName, resetUrl, language, 60);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const { data, error } = await this.resend.emails.send({
        from: `Oliva <${this.fromEmail}>`,
        to: [email],
        subject,
        html: htmlContent
      });

      if (error) {
        this.logger.error(
          `Failed to send password reset email to ${this.maskEmail(email)}: ${error.message}`,
        );
        return false;
      }

      this.logger.log(
        `Password reset email sent successfully to ${this.maskEmail(email)}. MessageId: ${data.id}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send password reset email to ${this.maskEmail(email)}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Send welcome email to new user
   * @param email User email address
   * @param userName User full name
   * @param churchName Church name
   * @returns Promise<boolean> Success status
   */
  async sendWelcomeEmail(
    email: string,
    userName: string,
    churchName: string,
    churchId?: string,
  ): Promise<boolean> {
    try {
      if (!this.resend) {
        this.logger.error('Resend not initialized. Cannot send welcome email.');
        return false;
      }

      // Get church preferred language
      let language = 'pt';
      if (churchId) {
        const church = await this.churchRepository.findOne({ where: { id: churchId } });
        language = church?.preferredLanguage || 'pt';
      }
      
      const t = getTranslation(language).welcome;
      const htmlContent = getWelcomeEmail(userName, churchName, language);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const { data, error } = await this.resend.emails.send({
        from: `Oliva <${this.fromEmail}>`,
        to: [email],
        subject,
        html: htmlContent
      });

      if (error) {
        this.logger.error(
          `Failed to send welcome email to ${this.maskEmail(email)}: ${error.message}`,
        );
        return false;
      }

      this.logger.log(
        `Welcome email sent successfully to ${this.maskEmail(email)}. MessageId: ${data.id}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send welcome email to ${this.maskEmail(email)}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Send payment failure notification email to admin
   * @param churchId Church ID
   * @returns Promise<boolean> Success status
   */
  async sendPaymentFailedEmail(churchId: string): Promise<boolean> {
    try {
      if (!this.resend) {
        this.logger.error('Resend not initialized. Cannot send payment failed email.');
        return false;
      }

      // Find church and admin user
      const church = await this.churchRepository.findOne({
        where: { id: churchId },
        relations: ['users'],
      });

      if (!church) {
        this.logger.error(`Church not found: ${churchId}`);
        return false;
      }

      // Find admin user
      const adminUser = await this.userRepository.findOne({
        where: { churchId, role: { slug: 'ADMIN' } } as any,
        relations: ['members', 'role'],
      });

      if (!adminUser) {
        this.logger.error(`Admin user not found for church: ${churchId}`);
        return false;
      }

      // Get admin name from first member or use default
      const adminName = adminUser.members && adminUser.members.length > 0 
        ? adminUser.members[0].name 
        : 'Administrador';

      // Get church preferred language
      const language = church.preferredLanguage || 'pt';
      const t = getTranslation(language).paymentFailed;

      // Build dashboard URL
      const frontendUrl = this.configService.get<string>('FRONTEND_URL') || 'https://oliva.church';
      const dashboardUrl = `${frontendUrl}/settings/subscription`;

      const htmlContent = getPaymentFailedEmail(adminName, church.name, dashboardUrl, language);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const { data, error } = await this.resend.emails.send({
        from: `Oliva <${this.fromEmail}>`,
        to: [adminUser.email],
        subject,
        html: htmlContent
      });

      if (error) {
        this.logger.error(
          `Failed to send payment failed email to ${this.maskEmail(adminUser.email)}: ${error.message}`,
        );
        return false;
      }

      this.logger.log(
        `Payment failed email sent successfully to ${this.maskEmail(adminUser.email)} for church ${church.name}. MessageId: ${data.id}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send payment failed email for church ${churchId}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Mask email address for logging (security best practice)
   * Example: john.doe@example.com -> j***e@e***.com
   */
  private maskEmail(email: string): string {
    if (!email || !email.includes('@')) return '***';
    
    const [localPart, domain] = email.split('@');
    const maskedLocal = localPart.length > 2
      ? `${localPart[0]}***${localPart[localPart.length - 1]}`
      : '***';
    
    const [domainName, tld] = domain.split('.');
    const maskedDomain = domainName.length > 2
      ? `${domainName[0]}***`
      : '***';
    
    return `${maskedLocal}@${maskedDomain}.${tld}`;
  }

  /**
   * Health check method for monitoring
   */
  async isHealthy(): Promise<boolean> {
    return !!this.resend;
  }
}
