import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as nodemailer from 'nodemailer';
import { Transporter } from 'nodemailer';
import { UserRepository } from '../../entities/repository/user.repository';
import { ChurchRepository } from '../../entities/repository/church.repository';
import { getResetPasswordEmail, getWelcomeEmail, getPaymentFailedEmail } from './templates/template.loader';
import { getTranslation } from './i18n/translations';

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  private transporter: Transporter;
  private readonly isDevelopment: boolean;

  constructor(
    private readonly configService: ConfigService,
    private readonly userRepository: UserRepository,
    private readonly churchRepository: ChurchRepository,
  ) {
    this.isDevelopment = this.configService.get<string>('ENV') === 'development';
    this.initializeTransporter();
  }

  /**
   * Initialize Nodemailer transporter with Hostinger SMTP configuration
   * Connection pooling enabled for production scale
   */
  private initializeTransporter(): void {
    try {
      const host = this.configService.get<string>('EMAIL_HOST');
      const port = this.configService.get<number>('EMAIL_PORT');
      const user = this.configService.get<string>('EMAIL_USER');
      const pass = this.configService.get<string>('EMAIL_PASS');

      if (!host || !port || !user || !pass) {
        this.logger.warn('Email configuration missing. Email service will be disabled.');
        return;
      }

      this.transporter = nodemailer.createTransport({
        host,
        port,
        secure: false, // TLS
        auth: {
          user,
          pass,
        },
        pool: true, // Enable connection pooling for SaaS scale
        maxConnections: 5,
        maxMessages: 100,
        rateDelta: 1000, // 1 second
        rateLimit: 10, // Max 10 messages per second
        connectionTimeout: 10000, // 10 seconds
        socketTimeout: 10000, // 10 seconds
        tls: {
          rejectUnauthorized: false, // Allow self-signed certificates in development
        },
        logger: this.isDevelopment, // Enable debug logs in development
        debug: this.isDevelopment, // Enable debug mode in development
      });

      // Verify connection (non-blocking, just for logging)
      this.transporter.verify((error, success) => {
        if (error) {
          this.logger.warn(`Email transporter verification failed: ${error.message}. Service will continue but emails may not work. Check SMTP settings and network connectivity.`);
        } else {
          this.logger.log('Email service ready and verified ✓');
        }
      });
    } catch (error) {
      this.logger.error('Failed to initialize email transporter:', error.message);
    }
  }

  /**
   * Send password reset email to user
   * @param email User email address
   * @param resetToken Secure reset token generated by AuthService
   * @param resetUrl Full reset URL with token
   * @returns Promise<boolean> Success status
   */
  async sendPasswordReset(
    email: string,
    resetToken: string,
    resetUrl: string,
  ): Promise<boolean> {
    try {
      if (!this.transporter) {
        this.logger.error('Email transporter not initialized. Cannot send password reset email.');
        return false;
      }

      // Find user by email (without leaking user existence info)
      const user = await this.userRepository.findOne({ 
        where: { email },
        relations: ['church'],
      });
      
      if (!user) {
        // Don't reveal if user exists - log internally but return success to client
        this.logger.warn(`Password reset requested for non-existent email (not logged): ${this.maskEmail(email)}`);
        return true; // Security: Don't leak user existence
      }

      // Get church preferred language
      const language = user.church?.preferredLanguage || 'pt';
      const t = getTranslation(language).resetPassword;
      
      const userName = 'Usuário'; // User entity doesn't have name field
      const htmlContent = getResetPasswordEmail(userName, resetUrl, language, 60);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const fromAddress = this.configService.get<string>('EMAIL_USER');
      if (!fromAddress) {
        this.logger.error('EMAIL_USER not configured');
        return false;
      }

      const mailOptions = {
        from: `"Oliva" <${fromAddress}>`,
        to: email,
        subject,
        html: htmlContent,
        replyTo: 'noreply@oliva.church',
      };

      const info = await this.transporter.sendMail(mailOptions);

      this.logger.log(
        `Password reset email sent successfully to ${this.maskEmail(email)}. MessageId: ${info.messageId}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send password reset email to ${this.maskEmail(email)}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Send welcome email to new user
   * @param email User email address
   * @param userName User full name
   * @param churchName Church name
   * @returns Promise<boolean> Success status
   */
  async sendWelcomeEmail(
    email: string,
    userName: string,
    churchName: string,
    churchId?: string,
  ): Promise<boolean> {
    try {
      if (!this.transporter) {
        this.logger.error('Email transporter not initialized. Cannot send welcome email.');
        return false;
      }

      // Get church preferred language
      let language = 'pt';
      if (churchId) {
        const church = await this.churchRepository.findOne({ where: { id: churchId } });
        language = church?.preferredLanguage || 'pt';
      }
      
      const t = getTranslation(language).welcome;
      const htmlContent = getWelcomeEmail(userName, churchName, language);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const fromAddress = this.configService.get<string>('EMAIL_USER');
      if (!fromAddress) {
        this.logger.error('EMAIL_USER not configured');
        return false;
      }

      const mailOptions = {
        from: `"Oliva" <${fromAddress}>`,
        to: email,
        subject,
        html: htmlContent,
        replyTo: 'noreply@oliva.church',
      };

      const info = await this.transporter.sendMail(mailOptions);

      this.logger.log(
        `Welcome email sent successfully to ${this.maskEmail(email)}. MessageId: ${info.messageId}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send welcome email to ${this.maskEmail(email)}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Send payment failure notification email to admin
   * @param churchId Church ID
   * @returns Promise<boolean> Success status
   */
  async sendPaymentFailedEmail(churchId: string): Promise<boolean> {
    try {
      if (!this.transporter) {
        this.logger.error('Email transporter not initialized. Cannot send payment failed email.');
        return false;
      }

      // Find church and admin user
      const church = await this.churchRepository.findOne({
        where: { id: churchId },
        relations: ['users'],
      });

      if (!church) {
        this.logger.error(`Church not found: ${churchId}`);
        return false;
      }

      // Find admin user
      const adminUser = await this.userRepository.findOne({
        where: { churchId, role: { slug: 'ADMIN' } } as any,
        relations: ['members', 'role'],
      });

      if (!adminUser) {
        this.logger.error(`Admin user not found for church: ${churchId}`);
        return false;
      }

      // Get admin name from first member or use default
      const adminName = adminUser.members && adminUser.members.length > 0 
        ? adminUser.members[0].name 
        : 'Administrador';

      // Get church preferred language
      const language = church.preferredLanguage || 'pt';
      const t = getTranslation(language).paymentFailed;

      // Build dashboard URL
      const frontendUrl = this.configService.get<string>('FRONTEND_URL') || 'https://oliva.church';
      const dashboardUrl = `${frontendUrl}/settings/subscription`;

      const htmlContent = getPaymentFailedEmail(adminName, church.name, dashboardUrl, language);

      const subject = this.isDevelopment
        ? `[DEV] ${t.subject}`
        : t.subject;

      const fromAddress = this.configService.get<string>('EMAIL_USER');
      if (!fromAddress) {
        this.logger.error('EMAIL_USER not configured');
        return false;
      }

      const mailOptions = {
        from: `"Oliva" <${fromAddress}>`,
        to: adminUser.email,
        subject,
        html: htmlContent,
        replyTo: 'support@oliva.church',
      };

      const info = await this.transporter.sendMail(mailOptions);

      this.logger.log(
        `Payment failed email sent successfully to ${this.maskEmail(adminUser.email)} for church ${church.name}. MessageId: ${info.messageId}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `Failed to send payment failed email for church ${churchId}`,
        error.stack,
      );
      return false;
    }
  }

  /**
   * Mask email address for logging (security best practice)
   * Example: john.doe@example.com -> j***e@e***.com
   */
  private maskEmail(email: string): string {
    if (!email || !email.includes('@')) return '***';
    
    const [localPart, domain] = email.split('@');
    const maskedLocal = localPart.length > 2
      ? `${localPart[0]}***${localPart[localPart.length - 1]}`
      : '***';
    
    const [domainName, tld] = domain.split('.');
    const maskedDomain = domainName.length > 2
      ? `${domainName[0]}***`
      : '***';
    
    return `${maskedLocal}@${maskedDomain}.${tld}`;
  }

  /**
   * Health check method for monitoring
   */
  async isHealthy(): Promise<boolean> {
    try {
      if (!this.transporter) return false;
      await this.transporter.verify();
      return true;
    } catch {
      return false;
    }
  }
}
